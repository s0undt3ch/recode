{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>recode</code> leverages the capabilities of libCST (Library for Concrete Syntax Trees), a Python library designed for parsing, manipulating, and generating Python code in a syntax-preserving way. It builds upon libCST's codemod module, which provides utilities for transforming code programmatically.</p>"},{"location":"#key-differentiators","title":"Key Differentiators","text":""},{"location":"#chained-codemod-execution","title":"Chained Codemod Execution","text":"<p><code>recode</code> enables running multiple <code>codemod</code>'s in a single CLI execution, streamlining workflows compared to libCST's one-codemod-per-execution approach.</p>"},{"location":"#priority-management","title":"Priority Management","text":"<p>Codemods are applied in a predefined order based on priorities defined by the modules. This ensures automatic logical sequencing of transformations.</p>"},{"location":"#streamlined-features","title":"Streamlined Features","text":""},{"location":"#single-pass-efficiency","title":"Single-Pass Efficiency","text":"<p>Chained execution minimizes redundant parsing and tree-building processes, improving efficiency for large-scale projects.</p>"},{"location":"#focus-on-developer-productivity","title":"Focus on Developer Productivity","text":"<p>By reducing the need for multiple executions, <code>recode</code> enhances developer workflows, especially in CI/CD pipelines or batch processing.</p>"},{"location":"codemods/","title":"Codemods","text":"<p>Codemods are python modules which provide a subclass of BaseCodemod, these classes are resposible for the code modifications.</p> <p>How to modify code can be read on libCST's documentation. Do note that our BaseCodemod differs from the libCST implementation. A good place to know how to implement a codemod can be see in this project's source tree under <code>src/recode/mods</code>.</p>"},{"location":"codemods/#included-codemods","title":"Included codemods","text":"<p>There are a few <code>codemod</code>'s included with the project, and issuing a <code>--list</code> on the <code>recode</code> CLI will show you what's available.</p> <pre><code>Available codemods:\n - cli-dashes-over-underscores: Replace `_` with `-`, ie, `--a-command` instead of `--a_command` in CLI commands.\n - sqlfmt: Format SQL queries using the `sqlfluff` python package.\n</code></pre>"},{"location":"codemods/#project-specific-codemods","title":"Project Specific Codemods","text":"<p>Probably some of the <code>codemods</code> of a project are quite tailored to the project and not that broad that could be contributed to the <code>recode</code> project.</p> <p>In such cases, a project can host their own codemods in a directory and configure the codemod_paths configuration setting.</p> <p>When properly configured, issuing <code>--list</code> will now include the project codemods.</p>"},{"location":"codemods/#testing-codemods","title":"Testing codemods","text":"<p>We include Modcase which is a dataclass prepared to test codemods from files which serve as before and after examples, as long as a pattern is followed.</p> <p>For example: <pre><code>from __future__ import annotations\n\nimport pathlib\n\nimport pytest\n\nfrom codemod.mods.sql.fmt import FormatSQL\nfrom codemod.mods.sql.fmt import FormatSQLConfig\nfrom codemod.testing import Modcase\n\nFILES_PATH = pathlib.Path(__file__).parent.resolve() / \"files\" / \"fmt\"\n\n\ndef _get_case_id(case: Modcase) -&gt; str:\n    return case.name\n\n\ndef _get_cases() -&gt; list[Modcase]:\n    cases = []\n    for path in FILES_PATH.glob(\"*.py\"):\n        if \".updated.\" in path.name:\n            # We don't want to collect the .updated files\n            continue\n        cases.append(\n            Modcase(\n                path=path,\n                codemod=FormatSQL,\n                codemod_config=FormatSQLConfig(),\n            )\n        )\n    return cases\n\n\n@pytest.fixture(params=_get_cases(), ids=_get_case_id)\ndef fmt_case(request) -&gt; Modcase:\n    return request.param\n\n\ndef test_format_sql(fmt_case: Modcase):\n    fmt_case.assert_codemod()\n</code></pre></p> <p>The above <code>FILES_PATH</code> contains examples of code changes that are being tested, here's an example directory listing: <pre><code>Permissions Size User           Date Modified Name\n.rw-r--r--@  287 pedro.algarvio 16 Nov 12:44  \ue606 attribute-with-comment.py\n.rw-r--r--@  307 pedro.algarvio 16 Nov 12:40  \ue606 attribute-with-comment.updated.py\n.rw-r--r--@  210 pedro.algarvio 22 Nov 12:34  \ue606 bytestrings.py\n.rw-r--r--@  202 pedro.algarvio 22 Nov 12:34  \ue606 bytestrings.updated.py\n.rw-r--r--@ 2.4k pedro.algarvio 24 Nov 21:06  \ue606 case-when.py\n.rw-r--r--@ 2.8k pedro.algarvio 24 Nov 21:06  \ue606 case-when.updated.py\n.rw-r--r--@  293 pedro.algarvio 10 Nov 19:53  \ue606 funcall-with-comment.py\n.rw-r--r--@  313 pedro.algarvio 10 Nov 19:52  \ue606 funcall-with-comment.updated.py\n.rw-r--r--@  140 pedro.algarvio 10 Nov 12:26  \ue606 multiline-attribute.py\n.rw-r--r--@  132 pedro.algarvio 10 Nov 12:21  \ue606 multiline-attribute.updated.py\n.rw-r--r--@   28 pedro.algarvio  9 Nov 12:50  \ue606 oneline-attribute.py\n.rw-r--r--@   28 pedro.algarvio  9 Nov 12:50  \ue606 oneline-attribute.updated.py\n.rw-r--r--@ 1.6k pedro.algarvio 24 Nov 21:06  \ue606 weird-indentation-attr.py\n.rw-r--r--@ 1.6k pedro.algarvio 24 Nov 21:06  \ue606 weird-indentation-attr.updated.py\n.rw-r--r--@ 1.3k pedro.algarvio 22 Nov 12:34  \ue606 weird-indentation-call.py\n.rw-r--r--@ 1.3k pedro.algarvio 22 Nov 12:34  \ue606 weird-indentation-call.updated.py\n</code></pre></p> <p>To note that if a file before any codemods getting applied is called <code>a-file.py</code> then the updated file should be named <code>a-file.updated.py</code>.</p>"},{"location":"configuration/","title":"Configuration","text":"<p><code>recode</code> can be configured at the root of your repository with a <code>.recode.toml</code> file or in your project's <code>pyproject.toml</code>.</p> <p>All configuration options can seen on the Config class reference, but here are a few examples.</p>"},{"location":"configuration/#example-recodetoml","title":"Example <code>.recode.toml</code>","text":"<pre><code>[recode]\nselect = [\n    \"sqlfmt\",\n]\nexclude = [\n    # Exclude only makes sense if no select is defined, since all available\n    # codemods will be used, at which time we might want to exclude some.\n    \"sqlfmt\",\n]\ncodemod_paths = [\n    \".codemods/\"\n]\nprocess_pool_size = 2\n</code></pre>"},{"location":"configuration/#example-pyprojecttoml","title":"Example <code>pyproject.toml</code>","text":"<pre><code>[tool.recode]\nselect = [\n    \"sqlfmt\",\n]\nexclude = [\n    # Exclude only makes sense if no select is defined, since all available\n    # codemods will be used, at which time we might want to exclude some.\n    \"sqlfmt\",\n]\ncodemod_paths = [\n    \".codemods/\"\n]\nprocess_pool_size = 2\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>To install the <code>recode</code> tool for use in the CLI, use the following command:</p> <pre><code>pip install re-code\n</code></pre>"},{"location":"installation/#using-pre-commit","title":"Using pre-commit","text":"<p>To use the <code>recode</code> tool with pre-commit, add the following configuration to your <code>.pre-commit-config.yaml</code> file:</p> <pre><code>- repo: https://github.com/s0undt3ch/recode\n  rev: v1.0.0  # Use the appropriate version or branch\n  hooks:\n    - id: recode\n</code></pre> <p>Then, install the pre-commit hook by running:</p> <pre><code>pre-commit install --install-hooks\n</code></pre> <p>This will set up the <code>recode</code> tool to run automatically on your codebase as part of the pre-commit hooks.</p>"},{"location":"reference/recode/abc/","title":"recode.abc","text":"<p>Abstract base classes for defining codemod types and their configurations.</p>"},{"location":"reference/recode/abc/#recode.abc.BaseConfig","title":"BaseConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base configuration class for codemoders.</p> <p>Config:</p> <ul> <li><code>frozen</code>: <code>True</code></li> </ul>"},{"location":"reference/recode/abc/#recode.abc.BaseCodemod","title":"BaseCodemod","text":"<pre><code>BaseCodemod(\n    context: CodemodContext, config: CodemodConfigType\n)\n</code></pre> <p>               Bases: <code>VisitorBasedCodemodCommand</code>, <code>ABC</code>, <code>Generic[CodemodConfigType]</code></p> <p>Base class for codemoders.</p> Source code in <code>src/recode/abc.py</code> <pre><code>def __init__(self, context: CodemodContext, config: CodemodConfigType):\n    super().__init__(context)\n    self.config = config\n    self.__post_codemod_init__()\n</code></pre>"},{"location":"reference/recode/abc/#recode.abc.BaseCodemod.get_short_description","title":"get_short_description  <code>classmethod</code>","text":"<pre><code>get_short_description() -&gt; str\n</code></pre> <p>Return a short description of the codemod.</p> <p>This short description is used in the CLI to list available codemods and should be a single line.</p> <p>By default, it returns the first line of the class docstring, override this method to provide a custom description.</p> Source code in <code>src/recode/abc.py</code> <pre><code>@classmethod\ndef get_short_description(cls) -&gt; str:\n    \"\"\"\n    Return a short description of the codemod.\n\n    This short description is used in the CLI to list available codemods and should be a single line.\n\n    By default, it returns the first line of the class docstring, override this method to provide a\n    custom description.\n    \"\"\"\n    doc = cls.__doc__\n    if cls is None:\n        error_msg = f\"Codemod {cls.__name__} must have a docstring to be used in the CLI.\"\n        raise TypeError(error_msg)\n    if TYPE_CHECKING:\n        assert doc is not None\n    return doc.strip().splitlines()[0].strip()\n</code></pre>"},{"location":"reference/recode/config/","title":"recode.config","text":"<p>re:Code configuration.</p>"},{"location":"reference/recode/config/#recode.config.ConfigError","title":"ConfigError","text":"<p>               Bases: <code>ValueError</code></p> <p>Config related error.</p>"},{"location":"reference/recode/config/#recode.config.ConfigLoadError","title":"ConfigLoadError","text":"<p>               Bases: <code>ConfigError</code></p> <p>Exception raised when failing to load the configuration from file.</p>"},{"location":"reference/recode/config/#recode.config.InvalidConfigError","title":"InvalidConfigError","text":"<p>               Bases: <code>ConfigError</code></p> <p>Exception raised when the loaded configuration is not valid.</p>"},{"location":"reference/recode/config/#recode.config.Config","title":"Config  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Main codemod configuration schema.</p> <p>Config:</p> <ul> <li><code>frozen</code>: <code>True</code></li> <li><code>extra</code>: <code>allow</code></li> </ul> <p>Fields:</p> <ul> <li> <code>select</code>                 (<code>list[str]</code>)             </li> <li> <code>exclude</code>                 (<code>list[str]</code>)             </li> <li> <code>codemod_paths</code>                 (<code>list[Path]</code>)             </li> <li> <code>process_pool_size</code>                 (<code>int</code>)             </li> <li> <code>repo_root</code>                 (<code>Path</code>)             </li> <li> <code>fail_fast</code>                 (<code>bool</code>)             </li> </ul>"},{"location":"reference/recode/config/#recode.config.Config.select","title":"select  <code>pydantic-field</code>","text":"<pre><code>select: list[str]\n</code></pre> <p>List of codemods to run.</p> <p>When no selection is made, all available codemods are run.</p>"},{"location":"reference/recode/config/#recode.config.Config.exclude","title":"exclude  <code>pydantic-field</code>","text":"<pre><code>exclude: list[str]\n</code></pre> <p>List of codemods to exclude.</p> <p>Only makes sense when <code>select</code> is empty and all codemods are run.</p>"},{"location":"reference/recode/config/#recode.config.Config.codemod_paths","title":"codemod_paths  <code>pydantic-field</code>","text":"<pre><code>codemod_paths: list[Path]\n</code></pre> <p>List of additional paths to search for codemods.</p>"},{"location":"reference/recode/config/#recode.config.Config.process_pool_size","title":"process_pool_size  <code>pydantic-field</code>","text":"<pre><code>process_pool_size: int\n</code></pre> <p>Number of processes to use for parallel processing. Defaults to the number of available CPUs.</p>"},{"location":"reference/recode/config/#recode.config.Config.repo_root","title":"repo_root  <code>pydantic-field</code>","text":"<pre><code>repo_root: Path\n</code></pre> <p>The root directory of the repository. Defaults to the current working directory.</p>"},{"location":"reference/recode/config/#recode.config.Config.fail_fast","title":"fail_fast  <code>pydantic-field</code>","text":"<pre><code>fail_fast: bool = False\n</code></pre> <p>Stop processing as soon as possible after the first error.</p>"},{"location":"reference/recode/config/#recode.config.Config.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; Config\n</code></pre> <p>Load the configuration from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The configuration to load.</p> required <p>Returns:</p> Type Description <code>Config</code> <p>Config instance.</p> Source code in <code>src/recode/config.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Config:\n    \"\"\"\n    Load the configuration from a dictionary.\n\n    Arguments:\n        data: The configuration to load.\n\n    Returns:\n        Config instance.\n    \"\"\"\n    try:\n        return Config(**data)\n    except ValueError as exc:\n        error = f\"Invalid configuration: {exc}\"\n        raise InvalidConfigError(error) from exc\n</code></pre>"},{"location":"reference/recode/config/#recode.config.Config.from_default_file","title":"from_default_file  <code>classmethod</code>","text":"<pre><code>from_default_file(path: Path) -&gt; Config\n</code></pre> <p>Load the configuration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the configuration file.</p> required <p>Returns:</p> Type Description <code>Config</code> <p>Config instance.</p> Source code in <code>src/recode/config.py</code> <pre><code>@classmethod\ndef from_default_file(cls, path: Path) -&gt; Config:\n    \"\"\"\n    Load the configuration from a file.\n\n    Arguments:\n        path: The path to the configuration file.\n\n    Returns:\n        Config instance.\n    \"\"\"\n    try:\n        data = tomllib.loads(path.read_text(encoding=\"utf-8\"))\n    except tomllib.TOMLDecodeError as exc:\n        error = f\"Unable to parse {path}: {exc}\"\n        raise ConfigLoadError(error) from exc\n    else:\n        return cls.from_dict(data)\n</code></pre>"},{"location":"reference/recode/config/#recode.config.Config.from_pyproject_file","title":"from_pyproject_file  <code>classmethod</code>","text":"<pre><code>from_pyproject_file(path: Path) -&gt; Config\n</code></pre> <p>Load the configuration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the configuration file.</p> required <p>Returns:</p> Type Description <code>Config</code> <p>Config instance.</p> Source code in <code>src/recode/config.py</code> <pre><code>@classmethod\ndef from_pyproject_file(cls, path: Path) -&gt; Config:\n    \"\"\"\n    Load the configuration from a file.\n\n    Arguments:\n        path: The path to the configuration file.\n\n    Returns:\n        Config instance.\n    \"\"\"\n    try:\n        data = tomllib.loads(path.read_text(encoding=\"utf-8\"))\n    except tomllib.TOMLDecodeError as exc:\n        error = f\"Unable to parse {path}: {exc}\"\n        raise ConfigLoadError(error) from exc\n    else:\n        return cls.from_dict(data.get(\"tool\", {}).get(\"recode\", {}))\n</code></pre>"},{"location":"reference/recode/exc/","title":"recode.exc","text":"<p>re:Code related exceptions.</p>"},{"location":"reference/recode/exc/#recode.exc.ReCodeError","title":"ReCodeError","text":"<p>               Bases: <code>Exception</code></p> <p>re:Code specific exception.</p>"},{"location":"reference/recode/exc/#recode.exc.ReCodeSystemExit","title":"ReCodeSystemExit","text":"<pre><code>ReCodeSystemExit(code: int, message: str | None = None)\n</code></pre> <p>               Bases: <code>SystemExit</code></p> <p>re:Code system exit exception that accepts a message argument.</p> Source code in <code>src/recode/exc.py</code> <pre><code>def __init__(self, code: int, message: str | None = None):\n    if TYPE_CHECKING:\n        assert code is not None\n        assert isinstance(code, int)\n    super().__init__(code)\n    self.message = message\n</code></pre>"},{"location":"reference/recode/processor/","title":"recode.processor","text":"<p>re:Code processor.</p> <p>A fair chunk of this module just piggybacks on what libCST does, we just adapt to our own way of processing the files.</p>"},{"location":"reference/recode/processor/#recode.processor.ParallelTransformResult","title":"ParallelTransformResult  <code>dataclass</code>","text":"<pre><code>ParallelTransformResult(\n    successes: int,\n    failures: int,\n    warnings: int,\n    skips: int,\n    changed: int,\n)\n</code></pre> <p>This is a copy of :class:<code>~libcst.codemod._cli.ParallelTransformResult</code> with an extra <code>changed</code> field.</p>"},{"location":"reference/recode/processor/#recode.processor.Processor","title":"Processor","text":"<pre><code>Processor(\n    config: Config,\n    registry: Registry,\n    codemods: list[type[BaseCodemod]],\n)\n</code></pre> <p>re:Code codemod processor.</p> Source code in <code>src/recode/processor.py</code> <pre><code>def __init__(self, config: Config, registry: Registry, codemods: list[type[BaseCodemod]]) -&gt; None:\n    self.config = config\n    self.registry = registry\n    self.codemods = codemods\n    codemod_configs = {}\n    for codemod in codemods:\n        config_dict = getattr(config, codemod.NAME, {})\n        try:\n            codemod_config = codemod.CONFIG_CLS(**config_dict)\n        except AttributeError:\n            codemod_config = BaseConfig()\n        codemod_configs[codemod.NAME] = codemod_config\n    self.codemod_configs = codemod_configs\n</code></pre>"},{"location":"reference/recode/processor/#recode.processor.Processor.process","title":"process","text":"<pre><code>process(files: list[Path]) -&gt; ParallelTransformResult\n</code></pre> <p>Process the passed in list of paths.</p> Source code in <code>src/recode/processor.py</code> <pre><code>def process(self, files: list[Path]) -&gt; ParallelTransformResult:\n    \"\"\"\n    Process the passed in list of paths.\n    \"\"\"\n    _files = sorted({str(f.resolve()) for f in files})\n    total = len(_files)\n    progress = Progress(enabled=True, total=total)\n    chunk_size = 4\n    jobs = min(\n        self.config.process_pool_size,\n        (len(_files) + chunk_size - 1) // chunk_size,\n    )\n    if jobs &lt; 1:\n        error = \"Must have at least one job to process!\"\n        raise ReCodeSystemExit(code=1, message=error)\n\n    if total == 0:\n        return ParallelTransformResult(successes=0, failures=0, skips=0, warnings=0, changed=0)\n\n    pool_impl: partial[Pool] | type[DummyPool]\n    if total == 1 or jobs == 1:\n        # Simple case, we should not pay for process overhead.\n        # Let's just use a dummy synchronous pool.\n        jobs = 1\n        pool_impl = DummyPool\n    else:\n        pool_impl = partial(multiprocessing.Pool, maxtasksperchild=chunk_size)\n        # Warm the parser, pre-fork.\n        cst.parse_module(\"\")\n\n    inherited_dependencies: set[ProviderT] = set()\n    for codemod in self.codemods:\n        for dependency in codemod.get_inherited_dependencies():\n            inherited_dependencies.add(dependency)\n\n    metadata_manager = FullRepoManager(\n        self.config.repo_root,\n        _files,\n        list(inherited_dependencies),\n    )\n    metadata_manager.resolve_cache()\n\n    successes: int = 0\n    failures: int = 0\n    warnings: int = 0\n    skips: int = 0\n    changed: int = 0\n\n    with pool_impl(processes=jobs) as p:\n        try:\n            for result in p.imap_unordered(\n                partial(self._process_path, metadata_manager), _files, chunksize=chunk_size\n            ):\n                # Print an execution result, keep track of failures\n                _print_parallel_result(\n                    result,\n                    progress,\n                    unified_diff=False,\n                    show_changed=True,\n                    show_successes=False,\n                    hide_generated=True,\n                    hide_blacklisted=True,\n                )\n                progress.print(successes + failures + skips)\n\n                if isinstance(result.transform_result, TransformFailure):\n                    failures += 1\n                elif isinstance(result.transform_result, TransformSuccess):\n                    successes += 1\n                    if result.changed:\n                        changed += 1\n                elif isinstance(result.transform_result, (TransformExit, TransformSkip)):\n                    skips += 1\n\n                if isinstance(result.transform_result, TransformFailure) and self.config.fail_fast:\n                    break\n\n                warnings += len(result.transform_result.warning_messages)\n        finally:\n            progress.clear()\n\n    # Return whether there was one or more failure.\n    return ParallelTransformResult(\n        successes=successes, failures=failures, skips=skips, warnings=warnings, changed=changed\n    )\n</code></pre>"},{"location":"reference/recode/registry/","title":"recode.registry","text":"<p>re:Code registry.</p> <p>This holds the information about what codemods are available to be used.</p>"},{"location":"reference/recode/registry/#recode.registry.Registry","title":"Registry","text":"<pre><code>Registry()\n</code></pre> <p>Registry class to hold all available codemods.</p> Source code in <code>src/recode/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._codemods: list[type[BaseCodemod]] = []\n</code></pre>"},{"location":"reference/recode/registry/#recode.registry.Registry.load","title":"load","text":"<pre><code>load(search_paths: list[Path]) -&gt; None\n</code></pre> <p>Load all available codemods.</p> Source code in <code>src/recode/registry.py</code> <pre><code>def load(self, search_paths: list[Path]) -&gt; None:\n    \"\"\"\n    Load all available codemods.\n    \"\"\"\n    codemods: dict[str, type[BaseCodemod]] = {}\n    codemod: type[BaseCodemod]\n    for codemod in self._collect_from_entrypoints():\n        if codemod.NAME in codemods:\n            log.warning(\"Already loaded a codemod by the name of %s\", codemod.NAME)\n            continue\n        codemods[codemod.NAME] = codemod\n    for path in search_paths:\n        for codemod in self._collect_from_path(path):\n            if codemod.NAME in codemods:\n                log.warning(\"Already loaded a codemod by the name of %s\", codemod.NAME)\n                continue\n            codemods[codemod.NAME] = codemod\n    self._codemods[:] = sorted(codemods.values(), key=operator.attrgetter(\"PRIORITY\"))\n</code></pre>"},{"location":"reference/recode/registry/#recode.registry.Registry.codemods","title":"codemods","text":"<pre><code>codemods(\n    exclude_codemods: Iterable[str] = (),\n    select_codemods: Iterable[str] = (),\n) -&gt; Iterator[type[BaseCodemod]]\n</code></pre> <p>Returns all available codemods, optionally skipping those passed in <code>excluded_names</code>.</p> Source code in <code>src/recode/registry.py</code> <pre><code>def codemods(\n    self, exclude_codemods: Iterable[str] = (), select_codemods: Iterable[str] = ()\n) -&gt; Iterator[type[BaseCodemod]]:\n    \"\"\"\n    Returns all available codemods, optionally skipping those passed in `excluded_names`.\n    \"\"\"\n    for codemod in self._codemods:\n        if exclude_codemods and codemod.NAME in exclude_codemods:\n            continue\n        if select_codemods and codemod.NAME not in select_codemods:\n            continue\n        yield codemod\n</code></pre>"},{"location":"reference/recode/testing/","title":"recode.testing","text":"<p>re:Code testing support.</p>"},{"location":"reference/recode/testing/#recode.testing.Modcase","title":"Modcase  <code>dataclass</code>","text":"<pre><code>Modcase(\n    *,\n    path: Path,\n    codemod: type[BaseCodemod],\n    codemod_config: BaseConfig,\n)\n</code></pre>"},{"location":"reference/recode/testing/#recode.testing.Modcase.assert_codemod","title":"assert_codemod","text":"<pre><code>assert_codemod(expected_skip: bool = False) -&gt; None\n</code></pre> <p>This assertion is inspired by libCST's TestClass implementation.</p> Source code in <code>src/recode/testing.py</code> <pre><code>def assert_codemod(self, expected_skip: bool = False) -&gt; None:\n    \"\"\"\n    This assertion is inspired by libCST's TestClass implementation.\n    \"\"\"\n    # Make sure the original content does not match the updated content\n    log.debug(\"Testing %s\", self)\n    assert self.original != self.updated\n    context = CodemodContext(filename=str(self.path))\n    transform_instance = self.codemod(context, self.codemod_config.model_copy())\n    input_tree = parse_module(self.original, config=PartialParserConfig())\n    try:\n        output_tree = transform_instance.transform_module(input_tree)\n    except SkipFile:\n        if not expected_skip:\n            raise\n        output_tree = input_tree\n    else:\n        if expected_skip:\n            error = \"Expected SkipFile but was not raised\"\n            raise AssertionError(error)\n\n    # Make sure changes were made\n    assert output_tree.code != self.original\n    # Match what we have on file\n    assert output_tree.code == self.updated\n</code></pre>"},{"location":"reference/recode/utils/","title":"recode.utils","text":"<p>ReCode utilities.</p>"},{"location":"reference/recode/utils/#recode.utils.evaluated_string","title":"evaluated_string  <code>cached</code>","text":"<pre><code>evaluated_string(node: SimpleString) -&gt; str\n</code></pre> <p>Evaluate a SimpleString node into a python string.</p> Source code in <code>src/recode/utils.py</code> <pre><code>@cache\ndef evaluated_string(node: cst.SimpleString) -&gt; str:\n    \"\"\"\n    Evaluate a SimpleString node into a python string.\n    \"\"\"\n    return literal_eval(node.value)\n</code></pre>"},{"location":"reference/recode/utils/#recode.utils.get_full_module_name","title":"get_full_module_name","text":"<pre><code>get_full_module_name(module: Module) -&gt; str\n</code></pre> <p>Return a fully qualified name of a module.</p> Source code in <code>src/recode/utils.py</code> <pre><code>def get_full_module_name(module: cst.Module) -&gt; str:\n    \"\"\"\n    Return a fully qualified name of a module.\n    \"\"\"\n    parts: list[str] = []\n    while isinstance(module, cst.Attribute):\n        parts.insert(0, module.attr.value)\n        module = module.value\n    if isinstance(module, cst.Name):\n        parts.insert(0, module.value)\n    return \".\".join(parts)\n</code></pre>"},{"location":"reference/recode/mods/cli/flags/","title":"recode.mods.cli.flags","text":"<p>This codemod enforces the use of dashes over underscores in CLI arguments of ArgumentParser.</p> <p>For example, it will transform this code: <pre><code>parser.add_argument(\"--a_command\")\n</code></pre> into this code: <pre><code>parser.add_argument(\"--a-command\")\n</code></pre></p>"},{"location":"reference/recode/mods/cli/flags/#recode.mods.cli.flags.CliDashes","title":"CliDashes","text":"<pre><code>CliDashes(\n    context: CodemodContext, config: CodemodConfigType\n)\n</code></pre> <p>               Bases: <code>BaseCodemod</code></p> <p>Replace <code>_</code> with <code>-</code>, ie, <code>--a-command</code> instead of <code>--a_command</code> in CLI commands.</p> <p>This works if the parser argument is typed and only for ArgumentParser. <code>def foo(parser: ArgumentParser)</code>.</p> Source code in <code>src/recode/abc.py</code> <pre><code>def __init__(self, context: CodemodContext, config: CodemodConfigType):\n    super().__init__(context)\n    self.config = config\n    self.__post_codemod_init__()\n</code></pre>"},{"location":"reference/recode/mods/sql/fmt/","title":"recode.mods.sql.fmt","text":"<p>SQL Formatting codemod.</p> <p>This codemod uses the sqlfluff python package to format SQL queries.</p>"},{"location":"reference/recode/mods/sql/fmt/#recode.mods.sql.fmt.SqlDialect","title":"SqlDialect  <code>module-attribute</code>","text":"<pre><code>SqlDialect = Annotated[\n    str, AfterValidator(_check_sql_dialect)\n]\n</code></pre>"},{"location":"reference/recode/mods/sql/fmt/#recode.mods.sql.fmt.FormatSQLConfig","title":"FormatSQLConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for the SQL Formatting codemod.</p> <p>Fields:</p> <ul> <li> <code>dialect</code>                 (<code>SqlDialect</code>)             </li> <li> <code>sqlfluff_config_file</code>                 (<code>str</code>)             </li> </ul>"},{"location":"reference/recode/mods/sql/fmt/#recode.mods.sql.fmt.FormatSQLConfig.dialect","title":"dialect  <code>pydantic-field</code>","text":"<pre><code>dialect: SqlDialect = 'ansi'\n</code></pre> <p>The SQL dialect to use when formatting the SQL queries.</p>"},{"location":"reference/recode/mods/sql/fmt/#recode.mods.sql.fmt.FormatSQLConfig.sqlfluff_config_file","title":"sqlfluff_config_file  <code>pydantic-field</code>","text":"<pre><code>sqlfluff_config_file: str = str(\n    BUILNTIN_SQLFLUFF_CONFIG_FILE\n)\n</code></pre> <p>The path to a sqlfluff configuration file. If not provided, a default, opionated, configuration will be used.</p>"},{"location":"reference/recode/mods/sql/fmt/#recode.mods.sql.fmt.FormatSQL","title":"FormatSQL","text":"<pre><code>FormatSQL(\n    context: CodemodContext, config: CodemodConfigType\n)\n</code></pre> <p>               Bases: <code>BaseCodemod[FormatSQLConfig]</code></p> <p>Format SQL queries using the <code>sqlfluff</code> python package.</p> Source code in <code>src/recode/abc.py</code> <pre><code>def __init__(self, context: CodemodContext, config: CodemodConfigType):\n    super().__init__(context)\n    self.config = config\n    self.__post_codemod_init__()\n</code></pre>"},{"location":"reference/recode/mods/sql/utils/","title":"recode.mods.sql.utils","text":"<p>SQL mod related utility functions.</p>"}]}